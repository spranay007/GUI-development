$version 6.60

// main class for the layout
note group Note
{
  attr Bounds = <0,0,649,120>;
}

$rect <20,49,220,89>
$output false
class Beta1 : Core::Group
{
  $rect <0,540,200,580>
  inherited property Bounds = <0,0,800,480>;

  $rect <0,589,200,629>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <0,640,200,680>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  object Beta1::BatteryWindow BatteryWindow
  {
    preset Bounds = <0,0,200,480>;
  }

  $rect <20,20,160,60>
  object Beta1::Speeedometer Speeedometer
  {
    preset Bounds = <200,0,600,480>;
  }

  $rect <20,20,160,60>
  object Beta1::Indicaters Indicaters
  {
    preset Bounds = <600,160,800,320>;
  }

  $rect <20,20,160,60>
  object Beta1::TotalDistance TotalDistance
  {
    preset Bounds = <600,0,800,160>;
  }

  $rect <20,20,160,60>
  object Beta1::Temperature Temperature
  {
    preset Bounds = <600,320,800,480>;
  }

  $rect <820,49,1020,89>
  object Effects::FloatEffect FloatEffect
  {
    preset CycleDuration = 5000;
    preset Value2 = 2.0;
    preset Value1 = -2.0;
    preset Outlet = ^Speeedometer.Position;
  }

  $rect <820,100,1020,140>
  slot OnRelease
  {
    // Activate the effect to play the animation forward
    FloatEffect.Reversed = true;
    FloatEffect.Enabled  = true;
  }

  $rect <820,149,1020,189>
  slot OnPress
  {
    // Activate the effect to play the animation forward
    FloatEffect.Reversed = false;
    FloatEffect.Enabled  = true;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandler
  {
    preset Point4 = <200,0>;
    preset Point3 = <600,0>;
    preset Point2 = <600,480>;
    preset Point1 = <200,480>;
    preset OnRelease = OnRelease;
    preset OnPress = OnPress;
  }
}

// windows and dialogs
note group Note1
{
  attr Bounds = <0,129,649,320>;
}

$rect <20,169,220,209>
$output false
class BatteryWindow : Core::Group
{
  $rect <330,50,530,90>
  inherited property Bounds = <0,0,200,480>;

  $rect <330,100,530,140>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <330,0,530,40>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <340,150,1120,470>;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,0,200,480>;
    preset Color = Beta1::BackColor;
  }

  $rect <20,20,160,60>
  object Steel::VertBar VertBar0
  {
    preset Bounds = <20,120,180,380>;
    preset Type = Steel::LedType.Green;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle1
  {
    preset Bounds = <0,430,200,480>;
    preset Color = Beta1::CaptionColor;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <0,430,200,480>;
    preset String = "Battery Status";
    preset Font = Resources::FontVerdana24;
    preset Color = Beta1::TextColor;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle2
  {
    preset Bounds = <0,0,200,50>;
    preset Color = Beta1::CaptionColor;
  }
}

$rect <20,220,220,260>
$output false
class Speeedometer : Core::Group
{
  $rect <480,0,680,40>
  inherited property Bounds = <0,0,460,529>;

  $rect <480,50,680,90>
  inherited method UpdateViewState()
  {
    super( aState );

    // Arrange the needle so that it appears rotated accordingly to the current value 
    // of the property Position. Assume, Position is valid in range -1.0 .. + 1.0
    WarpImage.RotateAndScale( <200,380>, -90.0 * Position, 2.0, 2.0 );
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,0,400,480>;
    preset Color = Beta1::BackColor;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle1
  {
    preset Bounds = <0,0,400,50>;
    preset Color = Beta1::CaptionColor;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <0,0,400,50>;
    preset String = "VECMOCON TECHNOLOGIES";
    preset Font = Resources::FontVerdana24;
    preset Color = Beta1::TextColor;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle2
  {
    preset Bounds = <0,430,400,480>;
    preset Color = Beta1::CaptionColor;
  }

  $rect <20,20,160,60>
  object Views::Text Text1
  {
    preset Bounds = <0,430,400,480>;
    preset String = "Speedometer";
    preset Font = Resources::FontVerdana24;
    preset Color = Beta1::TextColor;
  }

  $rect <480,100,680,140>
  property float Position = 0;

  $rect <480,150,680,190>
  onset Position
  {
    // Limit to valid range
    if ( value >  1.0 ) value =  1.0;
    if ( value < -1.0 ) value = -1.0;

    // The value doesn't change - nothing to do.
    if ( pure Position == value )
      return;

    // Remember the property's new value.
    pure Position = value;

    // Just request the component to update itself
    InvalidateViewState();
  }

  $rect <20,20,160,60>
  object Views::WarpImage WarpImage
  {
    preset Point4 = <194,423>;
    preset Point3 = <208,423>;
    preset Point2 = <208,183>;
    preset Point1 = <194,183>;
    preset LightingEffect = 1.0;
    preset SourceAnchor = <3,100>;
    preset Color = #8DF006FF;
    preset Bitmap = Resources::GaugeNeedle;
  }
}

$rect <429,169,629,209>
$output false
class TotalDistance : Beta1::RightWindow
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,200,160>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  inherited object Text
  {
    preset Bounds = <0,110,200,160>;
    preset String = "Distance";
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <220,230,1000,550>;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle2
  {
    preset Bounds = <0,0,200,50>;
    preset Color = Beta1::CaptionColor;
  }

  $rect <20,20,160,60>
  object Flat::DigitalDisplay DigitalDisplay
  {
    preset Bounds = <0,50,150,110>;
    preset CurrentValue = 1024;
    preset TextColor = Beta1::TextColor;
  }

  $rect <20,20,160,60>
  object Flat::Label Label
  {
    preset Bounds = <160,50,200,110>;
    preset String = "KM";
    preset TextColor = Beta1::TextColor;
  }
}

$rect <429,220,629,260>
$output false
class Indicaters : Beta1::RightWindow
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,200,160>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  inherited object Rectangle
  {
    preset Bounds = <0,0,200,160>;
  }

  $rect <20,20,160,60>
  inherited object Rectangle1
  {
    preset Bounds = <0,110,200,160>;
  }

  $rect <20,20,160,60>
  inherited object Text
  {
    preset Bounds = <0,110,200,160>;
    preset String = "Indicaters";
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <220,230,1000,550>;
  }

  $rect <20,20,160,60>
  object Flat::Indicator Indicator_i
  {
    preset Bounds = <70,40,130,100>;
    preset Icon = Flat::FlatDemoIcons;
    preset IconIndex = 2;
    preset Active = false;
    preset BackColorActive = Flat::ColorOfTheme;
    preset BackColor = Beta1::BackColor;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandler
  {
    preset Point4 = <140,50>;
    preset Point3 = <190,50>;
    preset Point2 = <190,100>;
    preset Point1 = <140,100>;
    preset OnPress = Right;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandler1
  {
    preset Point4 = <10,50>;
    preset Point3 = <60,50>;
    preset Point2 = <60,100>;
    preset Point1 = <10,100>;
    preset OnPress = Left;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandler2
  {
    preset Point4 = <70,40>;
    preset Point3 = <130,40>;
    preset Point2 = <130,100>;
    preset Point1 = <70,100>;
    preset OnPress = Indicator;
  }

  $rect <290,0,490,40>
  slot Indicator
  {
    /* set the indicator to active */
    Indicator_i.Active = true;

    /* start the bool effect to switch off the indicator after a short time */
    Indicator_b.Enabled = false;
    Indicator_b.Enabled = true;
  }

  $rect <290,40,490,80>
  slot Right
  {
    /* set the indicator to active */
    Right_i.Active = true;

    /* start the bool effect to switch off the indicator after a short time */
    Right_b.Enabled = false;
    Right_b.Enabled = true;
  }

  $rect <290,80,490,120>
  slot Left
  {
    /* set the indicator to active */
    Left_i.Active = true;

    /* start the bool effect to switch off the indicator after a short time */
    Left_b.Enabled = false;
    Left_b.Enabled = true;
  }

  $rect <500,0,700,40>
  object Effects::BoolEffect Indicator_b
  {
    preset Value2 = false;
    preset Value1 = true;
    preset Outlet = ^Indicator_i.Active;
    preset NoOfCycles = 1;
    preset CycleDuration = 1000;
  }

  $rect <500,40,700,80>
  object Effects::BoolEffect Right_b
  {
    preset Value2 = false;
    preset Value1 = true;
    preset Outlet = ^Right_i.Active;
    preset NoOfCycles = 1;
    preset CycleDuration = 1000;
  }

  $rect <500,80,700,120>
  object Effects::BoolEffect Left_b
  {
    preset Value2 = false;
    preset Value1 = true;
    preset Outlet = ^Left_i.Active;
    preset NoOfCycles = 1;
    preset CycleDuration = 1000;
  }

  $rect <20,20,160,60>
  object Flat::Indicator Right_i
  {
    preset Bounds = <140,50,190,100>;
    preset Icon = Flat::FlatDemoIcons;
    preset IconIndex = 11;
    preset BackColorActive = Flat::ColorOfTheme;
    preset BackColor = Beta1::BackColor;
  }

  $rect <20,20,160,60>
  object Flat::Indicator Left_i
  {
    preset Bounds = <10,50,60,100>;
    preset Icon = Flat::FlatDemoIcons;
    preset IconIndex = 10;
    preset BackColorActive = Flat::ColorOfTheme;
    preset BackColor = Beta1::BackColor;
  }
}

$rect <429,269,629,309>
$output false
class Temperature : Beta1::RightWindow
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,200,160>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  inherited object Text
  {
    preset String = "Temperature";
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <220,230,1000,550>;
  }

  $rect <20,20,160,60>
  object Flat::Gauge Gauge
  {
    preset Bounds = <30,0,180,120>;
    preset CurrentValue = 26;
    preset Caption = "°C";
    preset BackColor = Beta1::CaptionColor;
    preset NeedleColor = Beta1::TextColor;
    preset TextColor = Beta1::TextColor;
  }
}

$rect <229,169,429,209>
$output false
class RightWindow : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,200,160>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <220,230,1000,550>;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,0,200,160>;
    preset Color = Beta1::BackColor;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle1
  {
    preset Bounds = <0,110,200,160>;
    preset Color = Beta1::CaptionColor;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <0,110,200,160>;
    preset AutoSize = true;
    preset String = "Caption";
    preset Font = Resources::FontVerdana24;
    preset Color = Beta1::TextColor;
  }
}

// Layout and color constants
note group Note2
{
  attr Bounds = <660,0,1080,320>;
}

$rect <669,49,869,89>
$output false
const color BackColor = #212669FF;

$rect <669,100,869,140>
$output false
const color CaptionColor = #030055FF;

$rect <669,149,869,189>
$output false
const color TextColor = #8DF006FF;

$rect <869,49,1069,89>
$output false
const point Const = <800,480>;

$rect <20,269,220,309>
$output false
class SplashWindow : Core::Group
{
  $rect <880,0,1080,40>
  inherited property Bounds = <0,0,800,480>;

  $rect <880,100,1080,140>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <880,49,1080,89>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,0,800,480>;
  }

  $rect <20,20,160,60>
  object Views::Image Image1
  {
    preset Bounds = <240,29,570,337>;
    preset AutoSize = true;
    preset Bitmap = Beta1::logo;
  }

  $rect <20,20,160,60>
  object Views::Bevel Bevel
  {
    preset Bounds = <0,0,800,480>;
    preset Width = 10;
    preset ColorL = #B10700FF;
    preset ColorR = #B10700FF;
    preset ColorB = #B10700FF;
    preset ColorT = #B10700FF;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <120,320,709,449>;
    preset String = "Vecmocon Technologies";
    preset Font = Flat::FontXL;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text Text1
  {
    preset Bounds = <600,360,700,390>;
    preset String = "©";
    preset Font = Resources::FontArial24;
    preset Color = #000000FF;
  }
}

$rect <669,200,869,240>
$output false
resource Resources::Bitmap logo
{
  attr bitmapfile FileName = .\Capture.JPG;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <669,249,869,289>
$output false
resource Resources::Bitmap speedo
{
  attr bitmapfile FileName = .\speedo.jpg;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <20,369,220,409>
$output false
class DeviceClass : Templates::DeviceClass
{
  $rect <420,60,620,100>
  onset Property
  {
    // The property doesn't change -> nothing to do.
    if ( pure Property == value )
      return;

    // Remember the new value in the internal memory of the property.
    pure Property = value;

    // For target code generation you will use your specific device API 
    // to change the affected value.
    $if !$prototyper
      native ( value )
      {
        /*
           TO DO:

           You can call a function of your own device API or you simply
           modify a variable existing in your middleware to reflect the
           new value:

           YourDevice_SetSomeValue( value );

           or

           YourDevice_SomeVariable = value;
        */
      }
    $endif

    // Notify all associated property observers.
    notifyobservers ^Property;
  }

  // This property represents an individual setting or state value existing within \
  // the device.
  $rect <220,60,420,100>
  property int32 Property = 0;

  // This method is intended to be called by the device to notify the GUI application \
  // about an alternation of its setting or state value.
  $rect <20,60,220,100>
  $output true
  method void UpdateProperty( arg int32 aNewValue )
  {
    // Only if the reported value does differ from the one stored currently in the property.
    if ( aNewValue != pure Property )
    {
      // Remember the new value in the internal memory of the property.
      pure Property = aNewValue;

      // Notify all associated property observers.
      notifyobservers ^Property;
    }
  }

  // This object represents an individual system event.
  $rect <220,280,420,320>
  object Core::SystemEvent SystemEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <20,280,220,320>
  $output true
  method void TriggerEvent()
  {
    // Just trigger the system event. All associated system event handler
    // will then be notified automatically.
    SystemEvent.Trigger( null, false );

    /*
       HINT 1:

       When triggering the event you can pass an optional 'context' object.
       With it additional event specific data can be attached at the event
       and dispatched with it. All notified system event handler can thus
       evaluate this 'context' information.

       To do this, you will need to define a particular 'context' class
       suitable to store the event specific information. Then create an
       instance of the class, initialize it with all the specific context
       data and finally pass the instance in the first parameter of the
       Trigger() method:


       var YourUnit::ContextClass context = new YourUnit::ContextClass;

       context.SomeData1 = ...
       context.SomeData2 = ...

       SystemEvent.Trigger( context, false );


       You can add parameters to the method in order to simply receive
       values from the device.
    */

    /*
       HINT 2:

       When triggering a system event you can determine its priority. Per
       default system events are delivered strictly in the order in which
       they have been triggered. When you pass 'true' in the last parameter
       of Trigger() you can force the event to be dispatched early:

       SystemEvent.Trigger( null, true );
    */
  }

  // This method implements a device command.
  $rect <20,430,220,470>
  method int32 Command( arg int32 aParameter1, arg bool aParameter2 )
  {
    // The following code is used during prototyping only. It simply returns
    // a dummy value. No device specific API is used during prototyping.
    $if $prototyper
      /*
         TO DO:

         List all parameters of this method not used explicitly. This will
         suppress the Chora warnings because of unused parameters.
      */

      aParameter1;
      aParameter2;

      /*
         TO DO:

         The following code is necessary for command methods intended to
         return a value. It can be removed if the method is declared with
         'void' as its return data type.

         In the case a return value is desired, adapt the 'return' statement
         to match the method's return data type. The value is just a dummy
         used during prototyping only.
      */

      return 0;
    $endif

    // For target code generation you will use your specific device API 
    // to perform the command in the device.
    $if !$prototyper
      /*
         TO DO:

         The following variable declaration is reasonable for command methods
         which return a value. It can be removed if the method is declared with
         'void' as its return data type or if the return value is not obtained
         from the native code.

         Additionally you may need to adapt this declaration to the method's
         return data type.
      */

      var int32 result = 0;
       
      /*
         TO DO:

         The following native statement encloses the code to communicate with
         your device API. Chora expects here all variables accessed from the
         native code to be explicitly listed in the head of the native statement.
         
         Write here all parameters and locally declared variables you intend to 
         access from the native code.
      */

      native ( aParameter1, aParameter2, result )
      {
        /*
           TO DO:

           You can call a function of your own device API or you simply
           modify variables existing in your middleware to reflect the
           command:

           YourDevice_DoSomething( aParameter1, aParameter2, ... );

           or

           YourDevice_SomeVariable    = aParameter1;
           YourDevice_AnotherVariable = aParameter2;

           Also receive a return value:

           result = YourDevice_DoSomething();
        */
      }

      /*
         TO DO:

         The following 'return' statement is needed only when the command method
         is declared to return a value. Otherwise you can remove the statement.
      */
      return result;
    $endif
  }

  // Example of an interface to read and modify a device setting or state value
  note group Note1
  {
    attr Bounds = <10,10,630,110>;
  }

  // Example of an interface to react to a system event
  note group Note2
  {
    attr Bounds = <10,230,630,330>;
  }

  // Example of an interface to perform an operation in the device
  note group Note3
  {
    attr Bounds = <10,380,630,480>;
  }

  // The property 'Property' represents an individual setting or state value existing \
  // within the device. Through the associated 'onset' method all write operations \
  // to the property can be directed to your particular device API. The read accesses, \
  // in contrast, are handled internally by using the last known value of the property. \
  // See inline documentation inside the 'onset' method 'OnSetProperty'.
  // 
  // The method 'UpdateProperty', in turn, is intended to be called by the device \
  // to notify the GUI application about an alternation of a setting or state value \
  // represented by the property 'Property'. See inline documentation inside the \
  // method.
  // 
  // You will eventually need to change the data type of the property to match the \
  // data in your device (e.g. to 'bool', 'uint32', or 'string', etc.). Use for this \
  // purpose the attribute 'Type' of the property itself. Accordingly the declaration \
  // of the 'UpdateProperty' method may need an adaptation.
  note legend Note4
  {
    attr Bounds = <700,10,1540,220>;
  }

  note arrow Note5
  {
    attr Point1 = <630,60>;
    attr Point2 = <700,60>;
  }

  // The object 'SystemEvent' represents an individual system event. When the system \
  // event is triggered all associated system event handler are notified automatically.
  // 
  // The method 'TriggerEvent' method is intended to be called by the device to notify \
  // the GUI application about the particular system event represented by the object \
  // 'SystemEvent'. This method exists for your convenience only and is optional. \
  // See inline documentation inside the method.
  note legend Note6
  {
    attr Bounds = <700,230,1540,370>;
  }

  note arrow Note7
  {
    attr Point1 = <630,280>;
    attr Point2 = <700,280>;
  }

  // This method demonstrates the implementation of a device command. The GUI application \
  // can call the method with the intention to trigger the device to perform an action. \
  // It's up to you what the method does. You are free in the declaration of the \
  // method. The parameters and the return value can be changed. See inline documentation \
  // inside the method.
  note legend Note8
  {
    attr Bounds = <700,380,1540,470>;
  }

  note arrow Note9
  {
    attr Point1 = <630,430>;
    attr Point2 = <700,430>;
  }

  // More functionality ... ?
  // 
  // Within the device class you can add as many commands, system events and properties \
  // as required by your target device. Use for this purpose the templates from the \
  // Gallery folder 'Device'.
  note legend Note10
  {
    attr Bounds = <10,500,630,600>;
  }
}

$rect <429,369,629,409>
autoobject Beta1::DeviceClass Device;

// Device Integration
note group Note3
{
  attr Bounds = <0,329,649,420>;
}

$rect <869,200,1069,240>
$output false
resource Resources::Bitmap Bitmap
{
  attr bitmapfile FileName = .\back.jpg;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <420,49,620,89>
$output false
class try_1 : Core::Group
{
  $rect <869,0,1009,40>
  inherited property Bounds = <0,0,800,480>;

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,0,800,480>;
  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Bounds = <1,-50,801,550>;
    preset AutoSize = true;
    preset Bitmap = Beta1::Bitmap;
  }
}
